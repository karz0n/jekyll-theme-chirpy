<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://karz0n.github.io/</id><title>ZEON</title><subtitle></subtitle> <updated>2021-05-24T22:24:38+03:00</updated> <author> <name>Denys Asauliak</name> <uri>https://karz0n.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://karz0n.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="en-US" href="https://karz0n.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator> <rights> Â© 2021 Denys Asauliak </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>Google performance tools Overview</title><link href="https://karz0n.github.io/posts/google-performance-tools-overview/" rel="alternate" type="text/html" title="Google performance tools Overview" /><published>2021-05-23T00:00:00+03:00</published> <updated>2021-05-23T00:00:00+03:00</updated> <id>https://karz0n.github.io/posts/google-performance-tools-overview/</id> <content src="https://karz0n.github.io/posts/google-performance-tools-overview/" /> <author> <name>Denys Asauliak</name> </author> <category term="Development" /> <category term="Tools" /> <summary> Install $ sudo apt install libunwind-dev $ git clone git@github.com:gperftools/gperftools.git $ cd gperftools $ cmake -B build -S . -DCMAKE_INSTALL_PREFIX=$HOME/.local $ cmake --build build --parallel $ cmake --build build --target install Install pprof Pprof is a tool that used to work with profiles. $ curl -O https://storage.googleapis.com/golang/go1.16.4.linux-amd64.tar.gz $ sudo tar xf... </summary> </entry> <entry><title>How to use GDB tool</title><link href="https://karz0n.github.io/posts/how-to-use-gdb/" rel="alternate" type="text/html" title="How to use GDB tool" /><published>2021-03-03T00:00:00+02:00</published> <updated>2021-03-03T00:00:00+02:00</updated> <id>https://karz0n.github.io/posts/how-to-use-gdb/</id> <content src="https://karz0n.github.io/posts/how-to-use-gdb/" /> <author> <name>Denys Asauliak</name> </author> <category term="Development" /> <category term="Debug" /> <summary> Compile $ g++ -g -O2 app.cpp -o app.x Start $ gdb --args app.x --arg1 --arg1 ... (gdb) show args Argument list to give program being debugged when it is started is " --arg1 --arg1". (gdb) b main Breakpoint 1 at ... (gdb) run Useful Useful hot-keys display console interface: Ctrl+X; Ctrl+A clear display: Ctrl+L Useful commands reach main and stop: start run until break: ru... </summary> </entry> <entry><title>How to use addr2line tool</title><link href="https://karz0n.github.io/posts/how-to-use-addr2line-tool/" rel="alternate" type="text/html" title="How to use addr2line tool" /><published>2021-03-03T00:00:00+02:00</published> <updated>2021-03-03T00:00:00+02:00</updated> <id>https://karz0n.github.io/posts/how-to-use-addr2line-tool/</id> <content src="https://karz0n.github.io/posts/how-to-use-addr2line-tool/" /> <author> <name>Denys Asauliak</name> </author> <category term="Development" /> <category term="Debug" /> <summary> The addr2line tool is used to get the line in code by the address which is obtained in several ways. One of the way to obtain address is get it from dmesg log when segmentation fault has happened. For our example we will build and run simple program with invalid pointer dereference. Pay attention we are going to build our program with debug information: $ g++ -g main.cpp -o main.x $ ./main.x Se... </summary> </entry> <entry><title>How to disassemble object file</title><link href="https://karz0n.github.io/posts/how-to-disassemble-object-file/" rel="alternate" type="text/html" title="How to disassemble object file" /><published>2021-03-03T00:00:00+02:00</published> <updated>2021-03-03T00:00:00+02:00</updated> <id>https://karz0n.github.io/posts/how-to-disassemble-object-file/</id> <content src="https://karz0n.github.io/posts/how-to-disassemble-object-file/" /> <author> <name>Denys Asauliak</name> </author> <category term="Development" /> <category term="Debug" /> <summary> First of all we need object file without any opmization and linking with standard library: $ g++ -c -g -O0 file.cpp then we use objdump and disassemble object file with helpful annotation: $ objdump -gdSC -M intel file.o &amp;gt; file.d Also we can get code by lines with particular address of instruction in assemble code: $ readelf --debug-dump=decodedline file.o &amp;gt; file.lines </summary> </entry> <entry><title>Using LTO</title><link href="https://karz0n.github.io/posts/using-lto/" rel="alternate" type="text/html" title="Using LTO" /><published>2021-03-02T00:00:00+02:00</published> <updated>2021-03-02T00:00:00+02:00</updated> <id>https://karz0n.github.io/posts/using-lto/</id> <content src="https://karz0n.github.io/posts/using-lto/" /> <author> <name>Denys Asauliak</name> </author> <category term="Development" /> <category term="Configure" /> <summary> Link Time Optimization (LTO) gives GCC the capability of dumping its internal representation (GIMPLE) to disk, so that all the different compilation units that make up a single executable can be optimized as a single module. This expands the scope of inter-procedural optimizations to encompass the whole program (or, rather, everything that is visible at link time). Link Time Optimization does ... </summary> </entry> </feed>
